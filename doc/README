==========================
 A free 6DoF game project
==========================

:Author: Pim Goossens
:Contact: irc://irc.freenode.net/6dof

.. contents::

Introduction
============
This project aims to produce a free (as in freedom) 6DoF first person
shooter game. 6DoF stands for "six degrees of freedom", meaning
players can move in any direction and rotate along any axis, without
being affected by gravity. Only a few games of this type have ever
been created, namely the Descent series and Forsaken. The newest one,
Descent 3, was released in 1999, making it over 9 years old as of this
writing.

This ``README`` file contains some project documentation describing
the various components and how they interact with each other. As the
project grows bigger and the amount of documentation increases, it
will eventually be split up into a set of multiple files describing
each component separately.

Since this project is still in its early development stages, you won't
find many things that will interest you unless you are a programmer
who wants to learn how it is organized, and perhaps help out. This
``README`` file should help you get started.

Overview
========
The game consists of a core written in C that is augmented by a Lua_
environment and controlled by Lua scripts. At its base lies a global
configuration system and a set of components that provide low-level
functionality used throughout the game (such as math functions), take
care of user interaction (audio, video, input), and perform
computations that take too much time to be done in Lua (like physics
and low-level artificial intelligence functions).

.. _Lua: http://www.lua.org/

Core
====
This section describes the "glue" that ties the various components
together. `The Lua environment`_ has its own section further below.

Core project files
------------------
* ``common.h`` includes all header files used and defines a couple of
  macros used throughout the project, notably DEBUG and ERROR.

* ``config.c`` and ``config.h`` define the functions for retrieving
  configuration values in C code.

* ``config.lua`` sets up the configuration table and loads it with
  values from ``defaults.lua``.

* ``defaults.lua`` defines options and their initial default values.

* ``game.c`` and ``game.h`` define the core of the game world model
  and contain the main loop. (Currently the "model" is just the level
  with a camera flying through it - basic physics for the camera are
  also implemented here for now).

* ``global.c`` and ``global.h`` define global variables and
  miscellaneous functions that are used throughout the code.

* ``init.lua`` sets up the Lua environment and processes the
  commandline.

* ``lua_funcs.c`` and ``lua_funcs.h`` define miscellaneous Lua
  functions written in C. Currently these are just the ``unpack``
  function which acts in a way similar to Perl's function of the same
  name, and the ``binread`` function which combines this functionality
  with reading from a file handle. The latter is used extensively by
  the Descent and Forsaken level/model reader scripts.

* ``main.c`` contains the game's entry point. See below.

* ``scalar.h`` contains some macros for working with the ``scalar``
  type. It provides ``scalar`` equivalents for math library functions
  such as ``sin``, ``cos``, and ``sqrt``. These ``scalar`` versions
  use the ``s`` suffix, yielding function names like ``sins``,
  ``coss``, and ``sqrts``.

* ``types.h``: declares commonly used types. These include the
  ``vector`` and ``quat`` (quaternion) types. They are defined here
  instead of in ``vector.h`` and ``quaternion.h`` since some
  operations may involve both of these types, so they have to be
  declared before any functions that involve both types.

* ``util.lua`` contains miscellaneous functions written in Lua.

``main`` and the initialization process
---------------------------------------
When ``main()`` is called, the first thing the game does is create the
Lua environment and initialize it, then execute the ``init.lua``
script, which in turn runs ``config.lua`` to set up the configuration
table, then loads the Lua utility functions in ``util.lua`` and
``vector.lua``, and finally processes the commandline.

Controls goes back to C at which point the ``lua_funcs`` will be
registered (this step *may* later be performed before running
``init.lua``). The game then proceeds by initializing each subsystem
(audio_, graphics_, input_) and the game world code, and finally
running ``bindings.lua`` to load the user's input configuration.

What happens at this point is subject to some major change as the game
develops. Currently, a level is loaded as indicated by some
configuration values and the main game loop is entered immediately.

Debug information
-----------------
The game has a simple numbered debug level system. Debug information
is produced throughout the game's code by calling the DEBUG() macro,
which can be used like the ``printf`` function but preceded with a
debug level. There are 11 debug levels, ranging from 0 to 10. 0 means
no debug information, printing only warnings and errors. There are no
strict rules dictating what debug information should have which level,
but here are some guidelines with examples:

* 1 - global initialization steps::

    DEBUG(1, "Initializing graphics subsystem\n");

* 2 - modules initialized and configuration-dependent initialization
  steps::

    DEBUG(2, "Using SDL for graphics\n");
    DEBUG(2, "gfx_sdl: using video driver \"%s\"\n",
      SDL_VideoDriverName(drv_name, 64));
    DEBUG(2, "Found joystick %d: \"%s\"\n", i+1, SDL_JoystickName(i));

* 3 - initialization/shutdown-related subsystem functions called::

    DEBUG(3, "audio_null: init()\n");
    DEBUG(3, "gfx_sdl: setting screen mode to %dx%dx%d\n", width, height, bpp);
    (in Lua)  DEBUG(3, "Loading configuration from "..name)

* 4 - data file loading and incidentally used or mid-level
  subsystem functions::

    DEBUG(4, "audio_null: load_sound(%s)\n", filename);
    (in Lua)  DEBUG(4, ('Header says %d verts, %d cubes'):
                format(nverts, ncubes))

* 5 - commonly used (but not necessarily every frame) or low-level
  subsystem functions::

    DEBUG(5, "audio_null: play_sound(%d, %d, %.3f, %#x)\n",
      soundno, volume, panning, flags);
    DEBUG(5, "Calling C function for input event %d\n", event.id);

* 6-10 - details::

    DEBUG(6, "Key press event, id == %d\n", event->id);
    DEBUG(6, "init_lua_table(): input module initialized (%d inputs)\n",
      num_inputs);
    (in Lua)  DEBUG(6, 'Reading subobject '..sobj_num)
    DEBUG(7, "%s:%d: reading %d bytes\n", __FILE__, __LINE__, n);
    DEBUG(9, "binread(\"%s\", ...)\n", fmt);

* 8-10 - functions invoked at least once every frame::

    DEBUG(8, "Processing input events\n");
    DEBUG(8, "gfx_sdl: render()\n");

* 10 - trivial functions::

    DEBUG(10, "gfx_sdl: get_scene() = %#010tx\n", &scene);

Global configuration system
---------------------------
The game has a global table to store configuration values. Its purpose
is to make certain parameters easily adjustable by the user, and
easily accessible by the game's code (even its C code). Here's how it
works and how to use it:

* In the early stage of game initialization, a special Lua table
  called ``config`` is created and loaded with values from
  ``defaults.lua``. This file contains initial (default) values for
  the options. At the same time, it determines what options exist; it
  is not possible to add new options after initialization.

* Immediately after this, the game parses the commandline used to run
  it. Commandline options can be used to override the default values
  specified in ``defaults.lua``. The game looks for arguments of the
  form ``--option=value``, ``--no-option``, and ``--option``. The
  first form assigns a string or number value to an option. The second
  and third forms disable and enable a boolean (on/off) option,
  respectively.

* From within the Lua environment, options can be accessed as
  ``config.optionname``. For example::

    print(('The current screen mode is %dx%dx%d'):format(
      config.width, config.height, config.bpp
    ))

* In C code, use the ``config_get_int``, ``config_get_float``, and ``config_get_str`` functions. ``config_get_int`` is also used for booleans. Example::

    printf("Current mouse sensitivity: x=%f, y=%f\n",
      config_get_float("mousesensx"), config_get_float("mousesensy")
    );
    printf("Joystick is %s\n",
      config_get_int("joystick") ? "enabled" : "disabled"
    );

* Options can be changed from within the Lua environment, but there
  are no equivalent ``config_set_*`` functions in C. Currently, most
  (if not all) options are used only during initialization, so
  changing them afterwards has no effect. This *may* change if/when
  configuration events are introduced (see below).

That's pretty much all there is to it. To introduce a new option all
you have to do is add it to ``defaults.lua``, and you can start using
it.

Later on, an event system may be introduced that can notify modules of
changes in the configuration, so they can use local variables to hold
parameters and don't have to repeatedly poll the config table.

Modules
=======
These modules implement specific functions and are mostly independent
from each other.

(One unfortunate exception to this is currently the input subsystem,
which uses SDL_ to access the various input devices. This requires
that SDL also be used for the graphics component. If a new graphics
subsystem is written that doesn't use SDL, a new input module will
need to be written as well.)

The interface (``*.h``) files contain specifications and descriptions
for the functions they define; they will not be repeated here.

Audio
-----
A basic interface for audio modules has been designed and can be found
in the ``audio.h`` file. There is a "null" audio implementation that
provides the functions expected and used by the game's core, but does
not actually produce any sound.  It is the default audio module for
now, until the project has some sounds to use and an implementation
that produces sound, and may still remain useful in the future, e.g.
for dedicated servers.

A partial audio implementation based on SDL_mixer_ is also included,
but it may be a better idea to use OpenAL_ instead, since it provides a
3D sound interface.

.. _SDL_mixer: http://www.libsdl.org/projects/SDL_mixer/
.. _OpenAL: http://connect.creativelabs.com/openal/

File system
-----------
This module will take care of accessing game files and scripts.
Basically it is an abstraction layer that takes care of finding files
in their appropriate places and/or in archives as well as providing
I/O functions.

Currently, only a preliminary file interface and module have been
written and they aren't actually used yet. This should change soon...

PhysFS_ may be a useful library to use for this component.

.. _PhysFS: http://icculus.org/physfs/

Graphics
--------
The graphics module is currently written using the SDL_, OpenGL_, and
GLU_ interfaces. The interface (``gfx.h``) is currently simple, but
will have to be extended as features are added. In particular,
lighting has yet to be implemented (other than the single light
source originating from the camera - a temporary "solution").

Some implementation-independent graphics functions are also provided.
Currently these are just functions for loading geometry and texture
data into the graphics module in preparation for rendering, but more
functions will be added later for other things such as displaying
graphical effects and user interface components.

.. _SDL: http://www.libsdl.org/
.. _OpenGL: http://www.opengl.org/
.. _GLU: http://www.opengl.org/resources/libraries/glx/

Input
-----
Input functionality consists of two parts: first, an input module that
polls input devices and generates input events. There is currently
just one implementation, which is based on SDL. It should be noted
that this SDL-based implementation relies on its video subsystem being
used for the game window in order to provide keyboard and mouse input
functionality. This is currently the case, but if a new, alternative
graphics module is written it will need an accompanying input module
as well (unless that graphics module also relies on SDL's graphics
subsystem).

The second part is implementation-independent and provides functions
that bind input events (generated by the first part) to actions. It is
similar to Quake's input system. Events can be tied to special C-based
input functions, or to any Lua code.

There's a special prototype for C-based input functions::

    typedef void (*input_func)(const struct input_event *event);

This is a convenience to prevent such C-based functions from having to
work with the Lua stack in order to get at their arguments. They can
be registered as follows::

    /* Declare/define move_forward_func as an input_func. */
    input_register_func("forward", move_forward_func);

Inputs can then be bound to this function from within Lua::

    -- Binds the A key to move_forward_func
    input.bind('a', input.funcs.forward)

These commands can be put in the ``bindings.lua`` file, which is read
during initialization.

The input interface, including ``struct input_event``, is described in
``input.h``, the header file that contains its declaration.

Math
----
Some basic functions have been provided to work with vectors, which
are used to denote 3D coordinates, and quaternions to denote 3D object
orientations. Matrix functions may also be added at some point.

All of these functions use the ``scalar`` type for floating-point
numbers. The precision of this type can be set at compile-time and
defaults to the C ``float`` data type.

C math functions that write their result to a specified memory address
first compute their result locally. This is a little less efficient in
most cases, but it has the benefit of allowing their destination
parameter to equal one or both of their source parameters::

    vector v1 = {1.0f, 2.0f, 3.0f};
    vector v2 = {3.0f, 2.0f, 1.0f};
    vec_crossprod(&v1, &v1, &v2);
    /* v1 now contains {-4.0f, 8.0f, -4.0f}. */

`The Lua environment`_ is also enhanced with some vector functions.
See below for some examples. Quaternion and matrix functionality may
follow later on.

Physics
-------
This component has yet to be written. It will likely use ODE_. Some
temporary "physics" code is in place to provide 6DoF-style camera
movement and rotation. This code is currently in ``game.c`` (which
implements the main game loop), and will be taken out (or at least
moved elsewhere) later on when a game world and object model have been
added.

.. _ODE: http://www.ode.org/

Time
----
Provides game time and FPS (frames per second) information. The time
module is currently trivial, with just a few globally accessible
variables and a function to update them. This is enough for now. Later
on, functions may be added to speed up, slow down, and pause/resume
the game time, and provide functions to fire off time-based events.

The Lua environment
===================
The game uses Lua_ to provide a flexible scripting environment. It
will be used for most high-level stuff and to control what the game
does, such as displaying menus, starting levels, setting options, and
manipulating the game world.

Currently, the Lua environment is just used for configuration, input
binding, and generating level geometry data.

Configuration
-------------
The ``config`` table stores the configuration values. See the `Global
configuration system`_ section above for a more detailed description
of the configuration system.

Controls
--------
Input binding is done exclusively via the Lua environment. The
``input`` table holds all input-related tables and functions.
``input.id`` is a table that maps input names to input IDs.
``input.bindings`` holds the actual bindings - what inputs are mapped
to which functions. Neither of these two tables is meant to be
accessed directly; two functions ``input.bind`` and ``input.unbind``
are provided to add and remove bindings. An example of how to use
``input.bind`` has already been given in the Input_ section above.
Additional examples can be found in the ``bindings.lua`` file, which
is read and executed at the end of the initialization process.

Levels
------
Levels are loaded by executing a Lua script that will return the
vertex/face data to be put in the corresponding low-level structures
for processing by the game components that use it, notably graphics
and physics.

This provides some interesting opportunities for level designers,
since such scripts can produce this data in various ways. Anything
from providing static geometry data, to reading such data from various
file types, or even automatically generating it, or any combination of
these, is possible. Examples of the first two are already included.

A similar means of providing sound and texture data may be added later
on.

Models
------
Level / polymodel data table passed from Lua to C::

    {
        ['vertices'] = vertices;
        ['faces'] = faces;
    }

where

::

    vertices = { {x1,y1,z1}, {x2,y2,z2}, ... }
    faces = { v1, v2, ..., key = value, ... }

``key`` and ``value`` can be:

* ``['normal'] = {x,y,z}``: face normal.
* ``['texture'] = handle``: texture handle as provided by the graphics
  subsystem.

``v1``, ``v2``, ... are tables containing per-vertex data:

* ``['index'] = i``: vertex index.
* ``['normal'] = {x,y,z}``: per-vertex face normal.
* ``['texcoords'] = {s, t}``: texture coordinates.
* ``['material'] = handle``: material handle as provided by the
  graphics subsystem.

Lua functions to load levels and models will be provided later
(or sooner), in a way similar to the texture functions (see below).

Vectors
-------
Vectors can be created and used like this::

    v = vec(1,2,3)
    w = vec({3,2,1})
    print(('%d,%d,%d'):format(v.x, v.y, v.z)) -- '1,2,3' (coordinates)
    print(v+w) -- '(4, 4, 4)'
    print(v-w) -- '(-2, 0, 2)'
    print(v*2) -- '(2, 4, 6)'
    print(v*w) -- '10' (dot product)
    print(-v) -- '(-1, -2, -3)' (reverse)
    print(v:len()) -- '3.7416573867739' (magnitude)
    print(v:norm()) -- '(0.267261, 0.534522, 0.801784)' (normalized)
    print(v:cross(w)) -- '(-4, 8, -4)' (cross product)

Sounds
------
::

    -- load a sound sample
    audio.load('mysoundhandlename', 'filename.wav')
    -- play it
    handle = audio.play('mysoundhandlename', 65535, 0, 0)
    -- or positional --
    handle = audio.play3d('mysoundhandlename', vec(1, 2, 3), 65535, 0)
    -- stop the sound
    audio.stop(handle)
    -- unload it
    audio.free('mysoundhandlename')

Textures
--------
To load a texture into the graphics module and prepare it for
rendering::

    handle = gfx.texture({
        width = w;
        height = h;
        flags = 0; -- to be defined
        data = d;
    })

where ``w`` and ``h`` are integers and ``d`` is a Lua string
containing the pixel data in RGB format, one byte per color component.

The handle should be kept in the Lua environment somewhere until it's
no longer needed - when the handle gets garbage-collected, the
corresponding texture goes with it. The game keeps the level data
structure (which contains references to these handles) around and so
this need not be done explicitly.

Lua texture loaders can already be created and used this way; for
example::

    handle = gfx.texture(loadfile('mytexloader.lua')(args))

Materials
---------
Materials can be created and used in a way similar to textures::

    handle = gfx.material({
        flags = 0;
        color = {r,g,b};
        specular = {sr,sg,sb};
        alpha = 1;
    })
    handle2 = gfx.material({
        flags = gfx.MATERIAL_FULL;
        ambient = {ar,ag,ab};
        diffuse = {dr,dg,db};
        specular = {sr,sg,sb};
        emission = {er,eg,eb};
        shininess = 1;
        alpha = 1;
    })

**NOTE**: The material system is likely to change later, more so than
the rest of the graphics subsystem.

Miscellaneous Lua functions
---------------------------
These are some additional functions that don't fall into any other
category:

* a ``DEBUG`` function that acts similar to the C macro defined in
  ``common.h``. See the `Debug information`_ section for some
  examples;
* a ``warn`` function to issue warnings; currently equivalent to
  Lua's ``print`` function;
* ``unpack`` is similar to Perl's ``unpack`` and Python's
  ``struct.unpack``; it extracts binary data from a string::

    -- Reads a 32-bit signed integer and a float from str
    local i, f = unpack('if', str)

* ``binread`` works like ``unpack`` but reads its data from a file
  handle, automatically reading the correct amount of bytes from the
  stream::

    -- Reads a 16-bit signed integer followed by a vector (3 floats)
    -- (14 bytes total) from the filehandle f, storing the integer in
    -- n and the vector in v.
    local n, v = f:binread('hv')

* a ``binfile`` function to add the ``binread`` method to Lua file
  handles, for example::

    local f = binfile(io.open(config.lvlfile, 'rb'))

Copyright
=========
This game is released under the `GNU General Public License`_ (version
2 or later); a copyright notice follows::

    Copyright (C) 2009  Pim Goossens

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of
    the License, or (at your option) any later version.

    This program is distributed in the hope that it will be
    useful, but WITHOUT ANY WARRANTY; without even the implied
    warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
    PURPOSE.  See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public
    License along with this program; if not, see
    <http://www.gnu.org/licenses/>, or write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
    02110-1301 USA.

.. _GNU General Public License: COPYING
